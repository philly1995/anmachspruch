<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>Emoji Dodge ‚Äì Bierjagd üç∫</title>
  <style>
    :root{
      --bg:#0f0f14; --fg:#eaeaf0; --accent:#8b5cf6; --good:#10b981; --bad:#ef4444; --gold:#fbbf24;
    }
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{margin:0;background:radial-gradient(1200px 600px at 50% -200px, #1b1b28, var(--bg));color:var(--fg);display:grid;place-items:center;min-height:100svh;}
    .wrap{display:grid;gap:12px;padding:16px;width:min(820px,100%)}
    h1{margin:0;font-weight:800;letter-spacing:.2px;font-size:clamp(18px,4vw,26px)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .btn{appearance:none;border:0;border-radius:14px;padding:10px 14px;background:#1f1f2e;color:var(--fg);cursor:pointer;font-weight:700;box-shadow:0 6px 14px rgba(0,0,0,.3);}
    .btn:hover{background:#24243a}
    .btn.primary{background:linear-gradient(135deg,var(--accent),#22d3ee);color:#0a0a0f}
    .stat{padding:8px 12px;background:#171726;border-radius:12px;font-variant-numeric:tabular-nums}
    canvas{background:linear-gradient(#0b0b12,#0a0a0f);width:100%;height:auto;border-radius:18px;box-shadow:0 12px 28px rgba(0,0,0,.45);touch-action:none}
    .mobile{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .mobile .btn{padding:14px 0;font-size:18px}
    .hint{opacity:.8;font-size:14px}
    .toast{position:fixed;inset:auto 12px 12px auto;background:#111827;color:#e5e7eb;padding:10px 12px;border-radius:10px;opacity:.92}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Emoji Dodge ‚Äì <span style="color:var(--gold)">Bierjagd</span> üç∫<small style="opacity:.7;font-weight:500"> ‚Äì weiche ü•õ aus, sammle üç∫</small></h1>
    <div class="row">
      <button id="startBtn" class="btn primary">‚ñ∂Ô∏è Start</button>
      <button id="pauseBtn" class="btn">‚è∏Ô∏è Pause</button>
      <button id="resetBtn" class="btn">üîÅ Reset</button>
      <span class="stat">Score: <b id="score">0</b></span>
      <span class="stat">Best: <b id="best">0</b></span>
      <span class="stat">Level: <b id="level">1</b></span>
    </div>

    <!-- H√∂he reduziert von 720 auf 560 -->
    <canvas id="game" width="540" height="560" aria-label="Spielfeld" role="img"></canvas>

    <div class="mobile">
      <button class="btn" id="leftBtn">‚¨ÖÔ∏è Links</button>
      <button class="btn" id="rightBtn">Rechts ‚û°Ô∏è</button>
    </div>
    <p class="hint">Steuerung: ‚¨ÖÔ∏è‚û°Ô∏è oder <b>Tippen/Halten</b> links/rechts auf dem Spielfeld. Sammle üç∫ (+10 Punkte), weiche ü•õ aus. Treffer = Game Over.</p>
  </div>
  <div class="toast" id="toast" hidden></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Game state
    let running = false, paused = false, last = 0, acc = 0;
    let player, beers, obstacles, score, level, best=Number(localStorage.getItem('emojiBeerBest')||0);

    // UI els
    const sScore = document.getElementById('score');
    const sBest = document.getElementById('best');
    const sLevel = document.getElementById('level');
    sBest.textContent = best;

    // Entities
    const EMOJI = {
      player:'üèÉ', beer:'üç∫', water:'ü•õ'
    };

    function reset(){
      player = {x: W/2, y: H-70, w: 40, h: 40, speed: 5};
      beers = []; obstacles = []; score = 0; level = 1; acc=0; last=0; paused=false;
      for(let i=0;i<6;i++) spawnObstacle(true);
      for(let i=0;i<3;i++) spawnBeer(true);
      updateHUD();
    }

    function updateHUD(){
      sScore.textContent = Math.floor(score);
      sLevel.textContent = level;
    }

    function rand(a,b){return a+Math.random()*(b-a)}
    function spawnObstacle(init=false){
      const size = rand(26, 42);
      const o = {x: rand(26, W-26), y: init? rand(-H, -30): -30, w:size, h:size, vy: rand(2+level*0.5, 3.5+level), type: 'ob'};
      obstacles.push(o);
    }
    function spawnBeer(init=false){
      const c = {x: rand(20, W-20), y: init? rand(-H, -20): -20, w:30, h:30, vy: rand(2, 3.4), type:'beer'};
      beers.push(c);
    }

    function rectsOverlap(a,b){return Math.abs((a.x)-(b.x)) < (a.w/2+b.w/2) && Math.abs((a.y)-(b.y)) < (a.h/2+b.h/2)}

    // Input
    const keys = new Set();
    window.addEventListener('keydown',e=>{if(['ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
      if(e.code==='ArrowLeft') keys.add('L');
      if(e.code==='ArrowRight') keys.add('R');
      if(e.code==='Space') togglePause();
    });
    window.addEventListener('keyup',e=>{
      if(e.code==='ArrowLeft') keys.delete('L');
      if(e.code==='ArrowRight') keys.delete('R');
    });

    // Touch/Pointer auf Canvas: Tippen/Halten links/rechts steuert die Richtung
    let pointerActive = false;
    function handlePointer(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left;
      if(!Number.isFinite(x)) return;
      const left = x < rect.width/2;
      keys.delete('L'); keys.delete('R');
      keys.add(left ? 'L' : 'R');
    }
    canvas.addEventListener('pointerdown', (e)=>{ pointerActive = true; handlePointer(e); });
    canvas.addEventListener('pointermove', (e)=>{ if(pointerActive) handlePointer(e); });
    canvas.addEventListener('pointerup', ()=>{ pointerActive=false; keys.delete('L'); keys.delete('R'); });
    canvas.addEventListener('pointerleave', ()=>{ pointerActive=false; keys.delete('L'); keys.delete('R'); });
    // iOS Safari Touch (Fallback)
    canvas.addEventListener('touchstart', (e)=>{ pointerActive=true; handlePointer(e); }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{ if(pointerActive){ e.preventDefault(); handlePointer(e);} }, {passive:false});
    canvas.addEventListener('touchend', ()=>{ pointerActive=false; keys.delete('L'); keys.delete('R'); });

    // Mobile buttons (zus√§tzlich)
    function mobileHold(btn, set){ let id;
      const down = ()=>{set(true); id = setInterval(()=>set(true), 16)};
      const up = ()=>{clearInterval(id); set(false)};
      btn.addEventListener('pointerdown', down);
      btn.addEventListener('pointerup', up);
      btn.addEventListener('pointerleave', up);
      btn.addEventListener('pointercancel', up);
    }
    mobileHold(document.getElementById('leftBtn'), v=> v? keys.add('L'):keys.delete('L'))
    mobileHold(document.getElementById('rightBtn'), v=> v? keys.add('R'):keys.delete('R'))

    function togglePause(){ if(!running) return; paused = !paused; toast(paused? '‚è∏Ô∏è Pause':'‚ñ∂Ô∏è Weiter'); }

    // Loop
    function loop(ts){
      if(!running) return;
      if(!last) last = ts;
      const dt = Math.min(32, ts - last); last = ts;
      if(!paused){
        update(dt);
        draw();
      }
      requestAnimationFrame(loop);
    }

    function update(dt){
      // Level by time
      acc += dt; if(acc>6000){ acc=0; level++; spawnObstacle(); toast('‚§¥Ô∏è Level '+level) }

      // Move player
      const s = player.speed + level*0.1;
      if(keys.has('L')) player.x -= s;
      if(keys.has('R')) player.x += s;
      player.x = Math.max(24, Math.min(W-24, player.x));

      // Move obstacles
      for(const o of obstacles){
        o.y += o.vy; o.x += Math.sin((o.y+o.w)*0.01)*0.3;
      }
      for(let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        if(o.y - o.h/2 > H){ obstacles.splice(i,1); spawnObstacle(); }
      }

      // Beers
      for(const it of beers){ it.y += it.vy; }
      for(let i=beers.length-1;i>=0;i--){
        const it = beers[i];
        if(rectsOverlap(player, it)){
          score += 10; beers.splice(i,1); spawnBeer(); toast('+10 üç∫');
        } else if(it.y - it.h/2 > H){ beers.splice(i,1); spawnBeer(); }
      }

      // Collisions
      for(let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        if(rectsOverlap(player,o)){
          gameOver(); return;
        }
      }

      // Score trickle
      score += dt*0.01*(1+level*0.2);
      updateHUD();
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // subtle road lanes
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.07)'; ctx.lineWidth = 2; ctx.setLineDash([14,14]);
      for(let i=1;i<=2;i++){ ctx.beginPath(); ctx.moveTo((W/3)*i,0); ctx.lineTo((W/3)*i,H); ctx.stroke(); }
      ctx.restore();

      // player
      drawEmoji(EMOJI.player, player.x, player.y, 34);

      // obstacles (water glasses)
      for(const o of obstacles){ drawEmoji(EMOJI.water, o.x, o.y, o.w*0.8); }

      // beers
      for(const it of beers){ drawEmoji(EMOJI.beer, it.x, it.y, 28); }
    }

    function drawEmoji(e, x, y, size){
      ctx.font = `${size}px serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(e, x, y+2);
    }

    function toast(msg){
      const el = document.getElementById('toast');
      el.textContent = msg; el.hidden = false; clearTimeout(el._t);
      el._t = setTimeout(()=> el.hidden = true, 1200);
    }

    function gameOver(){
      running=false; paused=false;
      best = Math.max(best, Math.floor(score));
      localStorage.setItem('emojiBeerBest', best);
      sBest.textContent = best;
      updateHUD();
      toast('üíÄ Game Over ‚Äì Score '+Math.floor(score));
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff'; ctx.font = '28px system-ui'; ctx.textAlign='center'; ctx.fillText('Game Over', W/2, H/2-20);
      ctx.font = '18px system-ui'; ctx.fillText('‚ñ∂Ô∏è Start dr√ºcken f√ºr neue Runde', W/2, H/2+16);
    }

    // Buttons
    document.getElementById('startBtn').onclick = ()=>{ reset(); running=true; requestAnimationFrame(loop); }
    document.getElementById('pauseBtn').onclick = ()=> togglePause();
    document.getElementById('resetBtn').onclick = ()=>{ reset(); draw(); }

    // Boot
    reset(); draw();
  </script>
</body>
</html>
